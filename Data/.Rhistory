x.vec = c(1,0,1,0,1,0)
binomial.fun(y.vec, prob)
binomial.fun = function(y.vec, n, prob) {
return(-sum(y.vec*log(prob) + (n-y.vec)*log(n-prob) + log(choose(n, y.vec))))
}
x.vec = c(1,0,1,0,1,0)
log.fun(x.vec, 0.5)
binomial.fun(x.vec, 1, 0.5)
binomial.fun(x.vec, 3, 0.5)
binomial.fun(x.vec, 2, 0.5)
binomial.fun(y.vec, prob)
prob = seq(0, 1, length.out = 10)
y.vec = c(rep(1,9), rep(2, 1))
binomial.fun(y.vec, prob)
log.fun(y.vec, prob)
binomial.fun(y.vec, 1, prob)
y.vec
plot(prob, binomial.fun(y.vec, prob))
prob = seq(0, 1, length.out = 10)
plot(prob, binomial.fun(y.vec, 1, prob))
plot(prob, log.fun(y.vec, prob))
binomial.fun(y.vec, 3, prob)
binomial.fun(y.vec, 10, prob)
log.fun(y.vec, prob)
binomial.fun(y.vec, 10, 0.11111)
binomial.fun(y.vec, 1, 0.11111)
binomial.fun(y.vec, 1, 0.11111)
log.fun(y.vec, prob)
binomial.fun(y.vec, 1, 0.11111)
binomial.fun(x.vec, 1, 0.5)
log.fun(x.vec, 0.5)
binomial.fun(y.vec, 1, 0.11111)
binomial.fun(y.vec, 2, 0.11111)
binomial.fun(y.vec, 1, 0.11111)
log(choose(1, y.vec))
binomial.fun = function(y.vec, n=length(y.vec), prob) {
return(-sum(y.vec*log(prob) + (n-y.vec)*log(n-prob) + log(choose(n, y.vec))))
}
prob = seq(0, 1, length.out = 10)
y.vec = c(rep(1,9), rep(2, 1))
log(choose(1, y.vec))
log(choose(length(y.vec), y.vec))
plot(prob, binomial.fun(y.vec, 1, prob))
binomial.fun(y.vec, 1, 0.11111)
plot(prob, binomial.fun(y.vec, length(y.vec), prob))
plot(prob, binomial.fun(y.vec, length(y.vec), prob))
binomial.fun(y.vec, lenght(y.vec), 0.11111)
binomial.fun(y.vec, length(y.vec), 0.11111)
log.fun(y.vec, prob)
binomial.fun(y.vec, length(y.vec), 0.11111)
binomial.fun(y.vec, length(y.vec), prob)
binomial.fun(y.vec, length(y.vec), 0.33)
binomial.fun(y.vec, length(y.vec), 0.99)
binomial.fun(y.vec, length(y.vec), prob)
prob
binomial.fun(y.vec, length(y.vec), 0.0000000)
log.fun(y.vec, 0.0000000)
binomial.fun(y.vec, length(y.vec), 1.0000000)
log.fun(y.vec, prob)
log.fun(y.vec, 1.0000000)
binomial.fun(y.vec, length(y.vec), 1.0000000)
log.fun(y.vec, 1.1)
binomial.fun(y.vec, length(y.vec), 1.1)
binomial.fun = function(y.vec, n=max(y.vec), prob) {
return(-sum(y.vec*log(prob) + (n-y.vec)*log(n-prob) + log(choose(n, y.vec))))
}
binomial.fun(y.vec, max(y.vec), 1.0000000)
binomial.fun(y.vec, max(y.vec), 1.1)
binomial.fun = function(y.vec, n=max(y.vec), prob) {
return(-sum(y.vec*log(prob) + (n-y.vec)*log(1-prob) + log(choose(n, y.vec))))
}
binomial.fun(y.vec, max(y.vec), 1.0000000)
plot(prob, binomial.fun(y.vec, length(y.vec), prob))
plot(prob, binomial.fun(y.vec, max(y.vec), prob))
binomial.fun(y.vec, max(y.vec), 1.0000000)
binomial.fun(y.vec, max(y.vec), 0.1111)
binomial.fun(y.vec, max(y.vec), 1,1)
binomial.fun(y.vec, max(y.vec), 1.1)
log.fun(y.vec, 1.1)
binomial.fun(y.vec, max(y.vec), prob)
log.fun(y.vec, prob)
prob
for(pr in prob) {
por = binomial.fun(y.vec, max(y.vec), pr)
print(por)
}
plot(prob, binomial.fun(y.vec, max(y.vec), prob))
binomial.fun(y.vec, max(y.vec), prob)
binomial.fun(y.vec, length(y.vec), prob)
por = binomial.fun(y.vec, length(y.vec), pr)
for(pr in prob) {
por = binomial.fun(y.vec, length(y.vec), pr)
print(por)
}
log.fun(1, 0.5)
log.fun(x.vec, 0.5)
loss.fun = function(y.vec, prob) {
return(-mean(y.vec*log(prob) + (n-y.vec)*log(1-prob)))
}
loss.fun(x.vec,0.5)
loss.fun(x.vec,0.5)
return(-mean(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
loss.fun(x.vec,0.5)
loss.fun = function(y.vec, prob) {
return(-mean(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
}
loss.fun(x.vec,0.5)
log.fun(x.vec, 0.5)
binomial.fun(x.vec, 1, 0.5)
x.vec = c(1,0,1,0,1)
log.fun(x.vec, 0.5)
x.vec = c(1)
log.fun(x.vec, 0.5)
for(pr in prob) {
por = binomial.fun(y.vec, length(y.vec), pr)
print(por)
}
binomial.fun(y.vec, length(y.vec), prob)
loss.fun = function(y.vec, prob) {
return(-mean(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
}
loss.fun = function(y.vec, prob) {
return(-sum(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
}
loss.fun(x.vec, 0.5)
log.fun(x.vec, 0.5)
loss.fun(y.vec, prob)
loss.fun = function(y.vec, prob) {
return(-(sum(y.vec*log(prob) + (1-y.vec)*log(1-prob))))
}
loss.fun(y.vec, prob)
loss.fun(y.vec, prob)
loss.fun(y.vec, prob)
log.fun(y.vec, prob)
binomial.fun(56, 100, 0.5)
loss.fun = function(y.vec, prob) {
return(-mean(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
}
loss.fun(x.vec, 0.5)
loss.fun(y.vec, prob)
# Page 7 Ber(p) - optimal golden section
log.fun = function(y.vec, prob) {
return(-(sum(y.vec)*log(prob/(1-prob)) + length(y.vec)*log(1-prob)))
}
loss.fun = function(y.vec, prob) {
return(-sum(y.vec*log(prob) + (1-y.vec)*log(1-prob)))
}
for(pr in prob) {
por = binomial.fun(y.vec, length(y.vec), pr)
print(por)
}
for(pr in prob) {
por = binomial.fun(y.vec, max(y.vec), pr)
print(por)
}
Barg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = min(y.vec)
b = max(y.vec)
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = binomial.fun(y.vec, length(y.vec), c)
d.f = binomial.fun(y.vec, length(y.vec), d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = binomial.fun(y.vec, length(y.vec), d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = binomial.fun(y.vec, length(y.vec), c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Barg.fun(y.vec)
y.vec = c(rep(0,90), rep(1, 10))
Barg.fun(y.vec)
mean(y.vec)
poisson.fun(y.vec,  3)
poisson.fun = function(y.vec, lam) {
return(length(y.vec)*lam + sum(ln(factorial(y.vec))) - ln(lam)*sum(y.vec))
}
poisson.fun(y.vec,  3)
ln(exp(2))
log(exp(2))
log(2)
ln(2)
poisson.fun = function(y.vec, lam) {
return(length(y.vec)*lam + sum(log(factorial(y.vec))) - log(lam)*sum(y.vec))
}
poisson.fun(y.vec,  3)
Parg.fun(y.vec)
Parg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = min(y.vec)
b = max(y.vec)
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = poisson.fun(y.vec, c)
d.f = poisson.fun(y.vec, d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = poisson.fun(y.vec, d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = poisson.fun(y.vec, c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Parg.fun(y.vec)
exponential.fun = function(y.vec, lam) {
return(lam*sum(y.vec) - length(y.vec)*log(lam))
}
Earg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = min(y.vec)
b = max(y.vec)
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = exponential.fun(y.vec, c)
d.f = exponential.fun(y.vec, d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = exponential.fun(y.vec, d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = exponential.fun(y.vec, c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Earg.fun(y.vec)
mean(y.vec)
mean(y.vec)*length(y.vec)
exponential.fun = function(y.vec, lam) {
return(lam*sum(y.vec) - length(y.vec)*log(lam))
}
Earg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = min(y.vec)
b = max(y.vec)
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = exponential.fun(y.vec, c)
d.f = exponential.fun(y.vec, d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = exponential.fun(y.vec, d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = exponential.fun(y.vec, c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Earg.fun(y.vec)
Earg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = 0
b = 10
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = exponential.fun(y.vec, c)
d.f = exponential.fun(y.vec, d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = exponential.fun(y.vec, d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = exponential.fun(y.vec, c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Earg.fun(y.vec)
Earg.fun = function(y.vec, iter.max=100, eps=1e-7, alp=((-1)+sqrt(5))/2) {
a = 0
b = 100
for(iter in 1:iter.max) {
c = alp*a + (1-alp)*b
d = alp*b + (1-alp)*a
c.f = exponential.fun(y.vec, c)
d.f = exponential.fun(y.vec, d)
if(c.f > d.f) {
a = c
c = d
c.f = d.f
d = (1-alp)*a + alp*b
d.f = exponential.fun(y.vec, d)
} else {
b = d
d = c
d.f = c.f
c = alp*a + (1-alp)*b
c.f = exponential.fun(y.vec, c)
}
if(abs(b-a) < eps) break
}
return(mean(a,b))
}
Earg.fun(y.vec)
is.infinite(iFinal.dff$po_W)
# 투수 데이터 프레임 생성
library(mlbench)
library(dplyr)
library(lubridate)
library(tidyr)
rm(list=ls()) # clearing environment
cat("\014") # clearing Console
setwd('/Users/seongjae/Desktop/Datamining_23/Data') # SJ
getwd()
# 1. 데이터 읽기
aAllstarFull = read.csv('AllstarFull.csv')
aAwardsPlayers = read.csv('AwardsPlayers.csv')
aPeople = read.csv('People.csv')
aPitching = read.csv('Pitching.csv')
aPitchingPost = read.csv('PitchingPost.csv')
aSalaries = read.csv('Salaries.csv')
aTeams = read.csv('Teams.csv')
# 2. 데이터 확인 및 필요한 열만 추출 (앞에 my_)
# (1) target 데이터
my_salaries = subset(aSalaries, select = c(playerID, yearID, teamID, salary), subset = (aSalaries$yearID >= 1998))   # target -> 2016년까지만 있어서 아직 미결합
summary(my_salaries)
str(my_salaries)
boxplot(salary~yearID, data=my_salaries)    # 년도별 연봉 boxplot
my_salaries = subset(my_salaries, subset = (my_salaries$salary != 0))   # 연봉 0원인 사람
subset(aPitching, subset = (aPitching$playerID == 'martija02'))         # 데이터 없어서 삭제
# (2) feature들
# pitching 데이터
Pitching = subset(aPitching, select = -c(l_ERA, l_BAOpp), subset = aPitching$yearID >= 1998)
# 년도별 선수를 기준으로 통합 -> 최종 my_pitching
my_Pitching = Pitching %>% group_by(playerID, yearID) %>% reframe(stint=max(stint), teamID = teamID, lgID = lgID, l_W = sum(l_W), l_L = sum(l_L), l_G = sum(l_G), l_GS = sum(l_GS),
l_CG = sum(l_CG), l_SHO = sum(l_SHO), l_SV = sum(l_SV), l_IPouts = sum(l_IPouts), l_H = sum(l_H), l_ER = sum(l_ER), l_HR = sum(l_HR),
l_BB = sum(l_BB), l_SO = sum(l_SO), l_IBB = sum(l_IBB), l_WP = sum(l_WP), l_HBP = sum(l_HBP), l_BK = sum(l_BK), l_BFP = sum(l_BFP), l_GF = sum(l_GF),
l_R = sum(l_R), l_SH = sum(l_SH), l_SF = sum(l_SF), l_GIDP = sum(l_GIDP) )
my_Pitching = my_Pitching %>% group_by(playerID, yearID) %>% slice(1)   # 첫번째 행으로 병합
my_Pitching$l_ERA = (my_Pitching$l_ER*9)/(my_Pitching$l_IPouts/3)       # ERA 추가
my_Pitching$l_BAOpp = (my_Pitching$l_H)/(my_Pitching$l_BFP)             # BAOpp 추가
summary(my_Pitching)  # 데이터 확인
summary(aPitching)    # 원본 데이터 확인
# 전처리   ***NA값인 친구들 200으로 채워버림 -> 토론 필요!!***
my_Pitching[is.na(my_Pitching$l_ERA), c("playerID", "yearID", "l_ERA")]
my_Pitching[my_Pitching$l_ERA == Inf, c("playerID", "yearID", "l_ERA")]
#my_Pitching[is.na(my_Pitching$l_ERA), "l_ERA"]  = 200       # ERA가 NA인 사람 5명 -> 200으로 대체
#my_Pitching[my_Pitching$l_ERA == Inf, "l_ERA"]  = 200       # ERA가 무한인 사람   -> 200으로 대체
summary(my_Pitching)
# post pitching 데이터
PitchingPost = subset(aPitchingPost, select = -c(lgID, po_ERA, po_BAOpp), subset = aPitchingPost$yearID >= 1998)
distinct(PitchingPost, round, .keep_all = TRUE)['round']    # 라운드 종류 확인
# round별 통합 -> grouping (round=1)
my_PitchingPost = PitchingPost %>% group_by(playerID, yearID) %>% reframe(round = 1, teamID = teamID, po_W = sum(po_W), po_L = sum(po_L), po_G = sum(po_G), po_GS = sum(po_GS),
po_CG = sum(po_CG), po_SHO = sum(po_SHO), po_SV = sum(po_SV), po_IPouts = sum(po_IPouts), po_H = sum(po_H), po_ER = sum(po_ER), po_HR = sum(po_HR),
po_BB = sum(po_BB), po_SO = sum(po_SO), po_IBB = sum(po_IBB), po_WP = sum(po_WP), po_HBP = sum(po_HBP), po_BK = sum(po_BK), po_BFP = sum(po_BFP), po_GF = sum(po_GF),
po_R = sum(po_R), po_SH = sum(po_SH), po_SF = sum(po_SF), po_GIDP = sum(po_GIDP))
my_PitchingPost = my_PitchingPost %>% group_by(playerID, yearID) %>% slice(1)  # 첫번째 행 가져오기
my_PitchingPost$po_ERA = (my_PitchingPost$po_ER*9)/(my_PitchingPost$po_IPouts/3)       # ERA 추가
my_PitchingPost$po_BAOpp = (my_PitchingPost$po_H)/(my_PitchingPost$po_BFP)             # BAOpp 추가
summary(my_PitchingPost)
# 전처리   ***NA값인 친구들 200으로 채워버림 -> 토론 필요!!***
my_PitchingPost[is.na(my_PitchingPost$po_ERA), c("playerID", "yearID", "po_ERA")]
my_PitchingPost[my_PitchingPost$po_ERA ==Inf, c("playerID", "yearID", "po_ERA")]
my_PitchingPost[is.na(my_PitchingPost$po_BAOpp), c("playerID", "yearID", "po_BAOpp")]       # 1경기 출전했지만 한타자도 상대 안함
# 선수 기본 데이터
my_People = subset( aPeople, select = c(playerID, birthYear, birthCountry, throws, debut) )
summary(my_People)
# 올스타전 출전 여부 데이터
my_AllstarFull = subset(aAllstarFull, select = -c(gameID, lgID, startingPos, gameNum), subset = (aAllstarFull$yearID >= 1998))
my_AllstarFull[my_AllstarFull$yearID == 2020, ]   # 데이터 없음
summary(my_AllstarFull)
# 수상 데이터
my_AwardsPlayers = subset(aAwardsPlayers, select = -c(tie, lgID, notes), subset = (aAwardsPlayers$yearID >= 1998))
summary(my_AwardsPlayers)
#my_AwardsPlayers[my_AwardsPlayers$yearID == 2020, ]
awards = unique(my_AwardsPlayers$get_awardID)        # 수상 가능한 상 종류 -> 순서대로 라벨 인코딩
my_AwardsPlayers$get_awardID = as.numeric(factor(my_AwardsPlayers$get_awardID, levels=awards))
# 수상 내역 그룹핑
my_AwardsPlayers = my_AwardsPlayers %>% group_by(playerID, yearID) %>% reframe(n_award = n_distinct(get_awardID))
summary(my_AwardsPlayers)
# 팀 데이터
my_Teams = subset(aTeams, select = c("teamID", "yearID", "divID", "Rank", "G", "W", "attendance", "PPF"), subset = (aTeams$yearID >= 1998))
#attach(my_Teams)
#my_Teams["GW"] = W/G
#detach(my_Teams);
summary(my_Teams)
my_Teams[my_Teams$attendance == 0, ]     # 2020년시즌 코로나로 인한 무관중 경기
unique(my_Teams$teamID)   # 팀 이름 종류
# 1차 데이터 결합
# 투수 성적
playdata.df = left_join( my_Pitching, my_PitchingPost, by=c('playerID', 'yearID', 'teamID'))    # 투수 기록
other.df = full_join( my_AllstarFull, my_AwardsPlayers, by=c("playerID", "yearID"))             # 올스타 + 수상여부
# 확인
df1 = playdata.df[, c('playerID', 'yearID', 'teamID')]
df2 = my_Pitching[, c('playerID', 'yearID', 'teamID')]
setdiff(df1, df2)
# 2차 데이터 결합 -> 투수 정보 (성적 + 개인정보)
pitcher.df = inner_join(playdata.df, my_People, by='playerID')
# 3차 데이터 결합 -> 투수 정보 (성적 + 개인정보 + 추가 기록)
pfinal_pitcher.df = left_join( pitcher.df, other.df, by=c('playerID', 'yearID', 'teamID'), multiple = "all")
pfinal_pitcher.df[ !(pfinal_pitcher.df$playerID %in% pitcher.df$playerID), ]
# 확인 ***1개 열이 추가됨... 이유??***
df1 = pfinal_pitcher.df[, c('playerID', 'yearID', 'teamID')]
df2 = pitcher.df[, c('playerID', 'yearID', 'teamID')]
setdiff(df1, df2)
all_equal(df1, df2)
# 4차 데이터 결합 -> 투수 정보 (성적 + 개인정보 + 추가 기록 + 팀정보)
pfinal_pitcher_Team.df = inner_join( pfinal_pitcher.df, my_Teams, by=c('yearID', 'teamID'), multiple = "all")
# 최종 데이터 결합 -> 투수 정보 (성적 + 개인정보 + 추가 기록 + 팀정보 + 연봉)
iFinal.df = inner_join( pfinal_pitcher_Team.df, my_salaries, by=c('playerID', 'yearID', 'teamID'), multiple = "all")   # 2016년 이후 데이터 무시
lFinal.df = left_join( pfinal_pitcher_Team.df, my_salaries, by=c('playerID', 'yearID', 'teamID'), multiple = "all")    # 1998년~2022년 모든 투수 데이터
summary(lFinal.df)
summary(iFinal.df)
colnames(lFinal.df)
####### ============ SJ ============
sum(is.na(iFinal.df))
colSums(is.na(iFinal.df))
colSums(is.infinite(iFinal.df))
iFinal.df$GP[is.na(iFinal.df$GP)] <- 0 # GP : NA -> 0
iFinal.df$n_award[is.na(iFinal.df$n_award)] <- 0 # n_award : NA -> 0
iFinal.df$round[is.na(iFinal.df$round)] <- 0 # round : NA -> 0
iFinal.dff <- iFinal.df %>% mutate_at(vars(starts_with("po")), ~replace_na(., 0))   # po_ : NA -> 0
colSums(is.na(iFinal.dff))
lFinal.df[is.na(lFinal.df$salary), ]   # salary값이 없는 데이터 9,616개
lFinal.df[lFinal.df$yearID > 2016, 'salary']
# 수치형 변수만 뽑아내기 -> 상관계수 확인
num_cols = sapply(lFinal.df, is.numeric)
numeric.df = lFinal.df[num_cols]
df = cor(numeric.df)
df[, 'salary']
# 마지막 team 데이터와 합칠지 고민... -> 그냥 팀ID로 팀 정보만 key값으로 팀 데이터 빼오면 안되나??
str(lFinal.df)
# 종합본 저장
setwd('D:/R/데이터마이닝')
colSums(is.na(iFinal.dff))
iFinal.dff[iFinal.dff$po_ERA == Inf, ]
iFinal.dff[iFinal.dff$po_ERA == Inf, ] <- 200
iFinal.dff[iFinal.dff$po_ERA == Inf, ] = 200
iFinal.dff[iFinal.dff$po_ERA == Inf, ] = 200
View(iFinal.df)
View(iFinal.dff)
iFinal.dff[iFinal.dff$po_ERA == Inf, ] <- 200
as.numeric(iFinal.dff[iFinal.dff$po_ERA == Inf, ]) <- 200
as.numeric(iFinal.dff[iFinal.dff$po_ERA == Inf, ]) = 200
colSums(is.na(iFinal.df))
iFinal.dff[iFinal.dff$po_ERA == Inf, ] <- 200
str(iFinal.dff$po_ERA)
iFinal.dff[iFinal.dff$po_ERA == "Inf", ]
iFinal.dff[iFinal.dff$po_ERA == "Inf", ] <- 200
iFinal.dff[is.infinite(iFinal.dff$po_ERA) , ]
iFinal.dff[is.infinite(iFinal.dff$po_ERA) , ] <- 200.0
iFinal.dff[is.infinite(iFinal.dff$po_ERA) , ] <- "200"
iFinal.dff[is.infinite(iFinal.dff$po_ERA) , ] <- 0
iFinal.dff[is.infinite(iFinal.dff$po_ERA)]
iFinal.dff[is.na(iFinal.dff$po_ERA)]
iFinal.dff[iFinal.dff$po_ERA==Inf]
iFinal.dff[iFinal.dff$po_ERA==Inf, ]
iFinal.dff$po_ERA[iFinal.dff$po_ERA==Inf]
iFinal.dff$po_ERA[iFinal.dff$po_ERA==Inf] <- 0
View(iFinal.dff)
View(iFinal.dff)
# 최종 데이터 결합 -> 투수 정보 (성적 + 개인정보 + 추가 기록 + 팀정보 + 연봉)
iFinal.df = inner_join( pfinal_pitcher_Team.df, my_salaries, by=c('playerID', 'yearID', 'teamID'), multiple = "all")   # 2016년 이후 데이터 무시
lFinal.df = left_join( pfinal_pitcher_Team.df, my_salaries, by=c('playerID', 'yearID', 'teamID'), multiple = "all")    # 1998년~2022년 모든 투수 데이터
summary(lFinal.df)
summary(iFinal.df)
colnames(lFinal.df)
####### ============ SJ ============
sum(is.na(iFinal.df))
colSums(is.na(iFinal.df))
iFinal.df$GP[is.na(iFinal.df$GP)] <- 0 # GP : NA -> 0
iFinal.df$n_award[is.na(iFinal.df$n_award)] <- 0 # n_award : NA -> 0
iFinal.df$round[is.na(iFinal.df$round)] <- 0 # round : NA -> 0
iFinal.dff <- iFinal.df %>% mutate_at(vars(starts_with("po")), ~replace_na(., 0))   # po_ : NA -> 0
colSums(is.na(iFinal.dff))
iFinal.dff$po_ERA[iFinal.dff$po_ERA==Inf] <- 200
colSums(is.na(iFinal.dff))
View(iFinal.dff)
View(iFinal.dff)
